package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"slices"
	"sort"
	"time"
)

type busTime struct {
	Eta, RouteNo, DestinationName string
	WaitTime                      time.Duration
}

func kmb_bus_times(stop_ids []string) []busTime {
	var busTimes []busTime

	for _, stop_id := range stop_ids {
		resp, err := http.Get(fmt.Sprintf("https://data.etabus.gov.hk/v1/transport/kmb/stop-eta/%s", stop_id))

		if err != nil {
			log.Fatalln(err)
		}

		body, err := io.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		// Autogenerated via https://mholt.github.io/json-to-go/
		type JsonResponse struct {
			Type               string    `json:"type"`
			Version            string    `json:"version"`
			GeneratedTimestamp time.Time `json:"generated_timestamp"`
			Data               []struct {
				Co            string    `json:"co"`
				Route         string    `json:"route"`
				Dir           string    `json:"dir"`
				ServiceType   int       `json:"service_type"`
				Seq           int       `json:"seq"`
				DestTc        string    `json:"dest_tc"`
				DestSc        string    `json:"dest_sc"`
				DestEn        string    `json:"dest_en"`
				EtaSeq        int       `json:"eta_seq"`
				Eta           string    `json:"eta"`
				RmkTc         string    `json:"rmk_tc"`
				RmkSc         string    `json:"rmk_sc"`
				RmkEn         string    `json:"rmk_en"`
				DataTimestamp time.Time `json:"data_timestamp"`
			} `json:"data"`
		}

		var jsonResponse JsonResponse
		err = json.Unmarshal(body, &jsonResponse)
		if err != nil {
			fmt.Println(err)
		}

		//  load hk timezone
		loc, err := time.LoadLocation("Asia/Hong_Kong")
		if err != nil {
			fmt.Println(err)
			return nil
		}

		current_time := time.Now()
		departures := jsonResponse.Data

		for _, departure := range departures {
			if departure.Eta != "" {
				eta, err := time.ParseInLocation("2006-01-02T15:04:05+08:00", departure.Eta, loc)
				if err != nil {
					fmt.Println(err)
					return nil
				}

				waitTime := time.Time.Sub(eta, current_time).Truncate(time.Minute)

				newBusTime := busTime{Eta: departure.Eta, RouteNo: departure.Route, DestinationName: departure.DestEn, WaitTime: waitTime}
				if !slices.Contains(busTimes, newBusTime) { // Remove any duplicates returned by KMB
					busTimes = append(busTimes, newBusTime)
				}

			}
		}
	}

	// sort by arrival time
	sort.Slice(busTimes, func(i, j int) bool {
		return busTimes[i].Eta < busTimes[j].Eta
	})

	return busTimes
}

// for testing do not use
func _kmb_test() {
	// tso_wo_hang = "B959226950B0DEA7"
	// sai kung bus station = ""
	// mak pin = C7548A3C37ADC1AA
	stop_id := "B959226950B0DEA7"
	url := fmt.Sprintf("https://data.etabus.gov.hk/v1/transport/kmb/stop-eta/%s", stop_id)
	resp, err := http.Get(url)

	if err != nil {
		log.Fatalln(err)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	// Autogenerated via https://mholt.github.io/json-to-go/
	type JsonResponse struct {
		Type               string    `json:"type"`
		Version            string    `json:"version"`
		GeneratedTimestamp time.Time `json:"generated_timestamp"`
		Data               []struct {
			Co            string    `json:"co"`
			Route         string    `json:"route"`
			Dir           string    `json:"dir"`
			ServiceType   int       `json:"service_type"`
			Seq           int       `json:"seq"`
			DestTc        string    `json:"dest_tc"`
			DestSc        string    `json:"dest_sc"`
			DestEn        string    `json:"dest_en"`
			EtaSeq        int       `json:"eta_seq"`
			Eta           string    `json:"eta"`
			RmkTc         string    `json:"rmk_tc"`
			RmkSc         string    `json:"rmk_sc"`
			RmkEn         string    `json:"rmk_en"`
			DataTimestamp time.Time `json:"data_timestamp"`
		} `json:"data"`
	}

	var jsonResponse JsonResponse
	err = json.Unmarshal(body, &jsonResponse)
	if err != nil {
		fmt.Println(err)
	}

	//  load hk timezone
	loc, err := time.LoadLocation("Asia/Hong_Kong")
	if err != nil {
		fmt.Println(err)
		return
	}

	current_time := time.Now()
	departures := jsonResponse.Data

	// sort by arrival time
	sort.Slice(departures, func(i, j int) bool {
		return departures[i].Eta < departures[j].Eta
	})

	for _, departure := range departures {
		if departure.Eta != "" {
			eta, err := time.ParseInLocation("2006-01-02T15:04:05+08:00", departure.Eta, loc)
			if err != nil {
				fmt.Println(err)
				return
			}
			waitTime := time.Time.Sub(eta, current_time).Truncate(time.Minute)
			fmt.Printf("%4s: %5s (%s)\n", departure.Route, waitTime, eta.Format("15:04"))
		}
	}
}
