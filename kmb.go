package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"slices"
	"sort"
	"strconv"
	"time"
)

type busTime struct {
	Eta, RouteNo, DestinationName string
	WaitTime                      time.Duration
}

type route struct {
	RouteNo, Company, Bound, OrigEn, OrigSc, OrigTc, DestEn, DestSc, DestTc string
	ServiceType                                                             int
}

type stopInfo struct {
	KmbStopId, KmbNameEn, KmbNameTc, KmbNameSc string
	Latitude, Longitude                        float64
}

type routeStopInfo struct {
	RouteNo, Bound, ServiceType, Seq, KmbStopId, Name string
}

func kmb_bus_times(stop_ids []string) []busTime {
	var busTimes []busTime

	for _, stop_id := range stop_ids {
		resp, err := http.Get(fmt.Sprintf("https://data.etabus.gov.hk/v1/transport/kmb/stop-eta/%s", stop_id))

		if err != nil {
			log.Fatalln(err)
		}

		body, err := io.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		// Autogenerated via https://mholt.github.io/json-to-go/
		type JsonResponse struct {
			Type               string    `json:"type"`
			Version            string    `json:"version"`
			GeneratedTimestamp time.Time `json:"generated_timestamp"`
			Data               []struct {
				Route         string    `json:"route"`
				Dir           string    `json:"dir"`
				ServiceType   int       `json:"service_type"`
				Seq           int       `json:"seq"`
				DestTc        string    `json:"dest_tc"`
				DestSc        string    `json:"dest_sc"`
				DestEn        string    `json:"dest_en"`
				EtaSeq        int       `json:"eta_seq"`
				Eta           string    `json:"eta"`
				RmkTc         string    `json:"rmk_tc"`
				RmkSc         string    `json:"rmk_sc"`
				RmkEn         string    `json:"rmk_en"`
				DataTimestamp time.Time `json:"data_timestamp"`
			} `json:"data"`
		}

		var jsonResponse JsonResponse
		err = json.Unmarshal(body, &jsonResponse)
		if err != nil {
			fmt.Println(err)
		}

		//  load hk timezone
		loc, err := time.LoadLocation("Asia/Hong_Kong")
		if err != nil {
			fmt.Println(err)
			return nil
		}

		current_time := time.Now()

		for _, departure := range jsonResponse.Data {
			if departure.Eta != "" {
				eta, err := time.ParseInLocation("2006-01-02T15:04:05+08:00", departure.Eta, loc)
				if err != nil {
					fmt.Println(err)
					return nil
				}

				waitTime := time.Time.Sub(eta, current_time).Truncate(time.Minute)

				newBusTime := busTime{Eta: departure.Eta, RouteNo: departure.Route, DestinationName: departure.DestEn, WaitTime: waitTime}
				if !slices.Contains(busTimes, newBusTime) { // Remove any duplicates returned by KMB
					busTimes = append(busTimes, newBusTime)
				}

			}
		}
	}

	// sort by arrival time
	sort.Slice(busTimes, func(i, j int) bool {
		return busTimes[i].Eta < busTimes[j].Eta
	})

	return busTimes
}

func kmb_route_list() []route {
	var routes []route

	resp, err := http.Get("https://data.etabus.gov.hk/v1/transport/kmb/route/")
	if err != nil {
		log.Fatalln(err)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	// Autogenerated via https://mholt.github.io/json-to-go/
	type JsonResponse struct {
		Type               string    `json:"type"`
		Version            string    `json:"version"`
		GeneratedTimestamp time.Time `json:"generated_timestamp"`
		Data               []struct {
			Route       string `json:"route"`
			Bound       string `json:"bound"`
			ServiceType string `json:"service_type"`
			OrigEn      string `json:"orig_en"`
			OrigTc      string `json:"orig_tc"`
			OrigSc      string `json:"orig_sc"`
			DestEn      string `json:"dest_en"`
			DestTc      string `json:"dest_tc"`
			DestSc      string `json:"dest_sc"`
		} `json:"data"`
	}

	var jsonResponse JsonResponse
	err = json.Unmarshal(body, &jsonResponse)
	if err != nil {
		fmt.Println(err)
	}

	for _, routeInfo := range jsonResponse.Data {
		serviceType, err := strconv.Atoi(routeInfo.ServiceType)
		if err != nil {
			fmt.Printf("Error converting string to int: %v\n", err)
			return nil
		}

		newRoute := route{RouteNo: routeInfo.Route, Company: "KMB", Bound: routeInfo.Bound, ServiceType: serviceType, OrigEn: routeInfo.OrigEn, OrigTc: routeInfo.OrigTc, OrigSc: routeInfo.OrigSc, DestEn: routeInfo.DestEn, DestTc: routeInfo.DestTc, DestSc: routeInfo.DestSc}
		routes = append(routes, newRoute)
	}

	return routes
}

func kmbStopList() []stopInfo {
	var stopInfos []stopInfo

	resp, err := http.Get("https://data.etabus.gov.hk/v1/transport/kmb/stop")

	if err != nil {
		log.Fatalln(err)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	// Autogenerated via https://mholt.github.io/json-to-go/
	type JsonResponse struct {
		Type               string    `json:"type"`
		Version            string    `json:"version"`
		GeneratedTimestamp time.Time `json:"generated_timestamp"`
		Data               []struct {
			Stop   string `json:"stop"`
			NameEn string `json:"name_en"`
			NameTc string `json:"name_tc"`
			NameSc string `json:"name_sc"`
			Lat    string `json:"lat"`
			Long   string `json:"long"`
		} `json:"data"`
	}

	var jsonResponse JsonResponse
	err = json.Unmarshal(body, &jsonResponse)
	if err != nil {
		fmt.Println(err)
	}

	for _, stop := range jsonResponse.Data {
		latitude, _ := strconv.ParseFloat(stop.Lat, 64)
		longitude, _ := strconv.ParseFloat(stop.Long, 64)

		stopInfos = append(stopInfos, stopInfo{KmbStopId: stop.Stop, KmbNameEn: stop.NameEn, KmbNameTc: stop.NameTc, KmbNameSc: stop.NameSc, Latitude: latitude, Longitude: longitude})
	}

	return stopInfos
}

func kmbRouteStopList() []routeStopInfo {
	var routeStopInfos []routeStopInfo

	resp, err := http.Get("https://data.etabus.gov.hk/v1/transport/kmb/route-stop")

	if err != nil {
		log.Fatalln(err)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	// Autogenerated via https://mholt.github.io/json-to-go/
	type JsonResponse struct {
		Type               string    `json:"type"`
		Version            string    `json:"version"`
		GeneratedTimestamp time.Time `json:"generated_timestamp"`
		Data               []struct {
			Route       string `json:"route"`
			Bound       string `json:"bound"`
			ServiceType string `json:"service_type"`
			Seq         string `json:"seq"`
			Stop        string `json:"stop"`
		} `json:"data"`
	}

	var jsonResponse JsonResponse
	err = json.Unmarshal(body, &jsonResponse)
	if err != nil {
		fmt.Println(err)
	}

	for _, routeStop := range jsonResponse.Data {
		newRouteStopInfo := routeStopInfo{RouteNo: routeStop.Route, Bound: routeStop.Bound, ServiceType: routeStop.ServiceType, Seq: routeStop.Seq, KmbStopId: routeStop.Stop}
		routeStopInfos = append(routeStopInfos, newRouteStopInfo)
	}
	return routeStopInfos
}

// for testing do not use
func _kmb_test() {
	// tso_wo_hang = "B959226950B0DEA7"
	// sai kung bus station = ""
	// mak pin = C7548A3C37ADC1AA
	stop_id := "B959226950B0DEA7"
	url := fmt.Sprintf("https://data.etabus.gov.hk/v1/transport/kmb/stop-eta/%s", stop_id)
	resp, err := http.Get(url)

	if err != nil {
		log.Fatalln(err)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	// Autogenerated via https://mholt.github.io/json-to-go/
	type JsonResponse struct {
		Type               string    `json:"type"`
		Version            string    `json:"version"`
		GeneratedTimestamp time.Time `json:"generated_timestamp"`
		Data               []struct {
			Co            string    `json:"co"`
			Route         string    `json:"route"`
			Dir           string    `json:"dir"`
			ServiceType   int       `json:"service_type"`
			Seq           int       `json:"seq"`
			DestTc        string    `json:"dest_tc"`
			DestSc        string    `json:"dest_sc"`
			DestEn        string    `json:"dest_en"`
			EtaSeq        int       `json:"eta_seq"`
			Eta           string    `json:"eta"`
			RmkTc         string    `json:"rmk_tc"`
			RmkSc         string    `json:"rmk_sc"`
			RmkEn         string    `json:"rmk_en"`
			DataTimestamp time.Time `json:"data_timestamp"`
		} `json:"data"`
	}

	var jsonResponse JsonResponse
	err = json.Unmarshal(body, &jsonResponse)
	if err != nil {
		fmt.Println(err)
	}

	//  load hk timezone
	loc, err := time.LoadLocation("Asia/Hong_Kong")
	if err != nil {
		fmt.Println(err)
		return
	}

	current_time := time.Now()
	departures := jsonResponse.Data

	// sort by arrival time
	sort.Slice(departures, func(i, j int) bool {
		return departures[i].Eta < departures[j].Eta
	})

	for _, departure := range departures {
		if departure.Eta != "" {
			eta, err := time.ParseInLocation("2006-01-02T15:04:05+08:00", departure.Eta, loc)
			if err != nil {
				fmt.Println(err)
				return
			}
			waitTime := time.Time.Sub(eta, current_time).Truncate(time.Minute)
			fmt.Printf("%4s: %5s (%s)\n", departure.Route, waitTime, eta.Format("15:04"))
		}
	}
}
