// API Docs: https://data.gov.hk/en-data/dataset/hk-td-tis_21-etakmb
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"slices"
	"sort"
	"strconv"
	"time"
)

type busTime struct {
	Eta, RouteNo, DestinationName string
	WaitTime                      time.Duration
}

type stopInfo struct {
	KmbStopId, KmbNameEn, KmbNameTc, KmbNameSc string
	Latitude, Longitude                        float64
}

type routeStopInfo struct {
	Route, Bound, ServiceType, Seq, KmbStopId, Name string
}

func kmb_bus_times(stop_ids []string) []busTime {
	var busTimes []busTime

	for _, stop_id := range stop_ids {
		resp, err := http.Get(fmt.Sprintf("https://data.etabus.gov.hk/v1/transport/kmb/stop-eta/%s", stop_id))

		if err != nil {
			log.Fatalln(err)
		}

		body, err := io.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		// Autogenerated via https://mholt.github.io/json-to-go/
		type JsonResponse struct {
			Type               string    `json:"type"`
			Version            string    `json:"version"`
			GeneratedTimestamp time.Time `json:"generated_timestamp"`
			Data               []struct {
				Co            string    `json:"co"`
				Route         string    `json:"route"`
				Dir           string    `json:"dir"`
				ServiceType   int       `json:"service_type"`
				Seq           int       `json:"seq"`
				DestTc        string    `json:"dest_tc"`
				DestSc        string    `json:"dest_sc"`
				DestEn        string    `json:"dest_en"`
				EtaSeq        int       `json:"eta_seq"`
				Eta           string    `json:"eta"`
				RmkTc         string    `json:"rmk_tc"`
				RmkSc         string    `json:"rmk_sc"`
				RmkEn         string    `json:"rmk_en"`
				DataTimestamp time.Time `json:"data_timestamp"`
			} `json:"data"`
		}

		var jsonResponse JsonResponse
		err = json.Unmarshal(body, &jsonResponse)
		if err != nil {
			fmt.Println(err)
		}

		//  load hk timezone
		loc, err := time.LoadLocation("Asia/Hong_Kong")
		if err != nil {
			fmt.Println(err)
			return nil
		}

		current_time := time.Now()
		departures := jsonResponse.Data

		for _, departure := range departures {
			if departure.Eta != "" {
				eta, err := time.ParseInLocation("2006-01-02T15:04:05+08:00", departure.Eta, loc)
				if err != nil {
					fmt.Println(err)
					return nil
				}

				waitTime := time.Time.Sub(eta, current_time).Truncate(time.Minute)

				newBusTime := busTime{Eta: departure.Eta, RouteNo: departure.Route, DestinationName: departure.DestEn, WaitTime: waitTime}
				if !slices.Contains(busTimes, newBusTime) { // Remove any duplicates returned by KMB
					busTimes = append(busTimes, newBusTime)
				}

			}
		}
	}

	// sort by arrival time
	sort.Slice(busTimes, func(i, j int) bool {
		return busTimes[i].Eta < busTimes[j].Eta
	})

	return busTimes
}

// for testing do not use
func _kmb_test() {
	// tso_wo_hang = "B959226950B0DEA7"
	// sai kung bus station = ""
	// mak pin = C7548A3C37ADC1AA
	stop_id := "B959226950B0DEA7"
	url := fmt.Sprintf("https://data.etabus.gov.hk/v1/transport/kmb/stop-eta/%s", stop_id)
	resp, err := http.Get(url)

	if err != nil {
		log.Fatalln(err)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	// Autogenerated via https://mholt.github.io/json-to-go/
	type JsonResponse struct {
		Type               string    `json:"type"`
		Version            string    `json:"version"`
		GeneratedTimestamp time.Time `json:"generated_timestamp"`
		Data               []struct {
			Co            string    `json:"co"`
			Route         string    `json:"route"`
			Dir           string    `json:"dir"`
			ServiceType   int       `json:"service_type"`
			Seq           int       `json:"seq"`
			DestTc        string    `json:"dest_tc"`
			DestSc        string    `json:"dest_sc"`
			DestEn        string    `json:"dest_en"`
			EtaSeq        int       `json:"eta_seq"`
			Eta           string    `json:"eta"`
			RmkTc         string    `json:"rmk_tc"`
			RmkSc         string    `json:"rmk_sc"`
			RmkEn         string    `json:"rmk_en"`
			DataTimestamp time.Time `json:"data_timestamp"`
		} `json:"data"`
	}

	var jsonResponse JsonResponse
	err = json.Unmarshal(body, &jsonResponse)
	if err != nil {
		fmt.Println(err)
	}

	//  load hk timezone
	loc, err := time.LoadLocation("Asia/Hong_Kong")
	if err != nil {
		fmt.Println(err)
		return
	}

	current_time := time.Now()
	departures := jsonResponse.Data

	// sort by arrival time
	sort.Slice(departures, func(i, j int) bool {
		return departures[i].Eta < departures[j].Eta
	})

	for _, departure := range departures {
		if departure.Eta != "" {
			eta, err := time.ParseInLocation("2006-01-02T15:04:05+08:00", departure.Eta, loc)
			if err != nil {
				fmt.Println(err)
				return
			}
			waitTime := time.Time.Sub(eta, current_time).Truncate(time.Minute)
			fmt.Printf("%4s: %5s (%s)\n", departure.Route, waitTime, eta.Format("15:04"))
		}
	}
}

func kmbStops() []stopInfo {
	var stopInfos []stopInfo

	resp, err := http.Get("https://data.etabus.gov.hk/v1/transport/kmb/stop")

	if err != nil {
		log.Fatalln(err)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	// Autogenerated via https://mholt.github.io/json-to-go/
	type JsonResponse struct {
		Type               string    `json:"type"`
		Version            string    `json:"version"`
		GeneratedTimestamp time.Time `json:"generated_timestamp"`
		Data               []struct {
			Stop   string `json:"stop"`
			NameEn string `json:"name_en"`
			NameTc string `json:"name_tc"`
			NameSc string `json:"name_sc"`
			Lat    string `json:"lat"`
			Long   string `json:"long"`
		} `json:"data"`
	}

	var jsonResponse JsonResponse
	err = json.Unmarshal(body, &jsonResponse)
	if err != nil {
		fmt.Println(err)
	}

	for _, stop := range jsonResponse.Data {
		latitude, _ := strconv.ParseFloat(stop.Lat, 64)
		longitude, _ := strconv.ParseFloat(stop.Long, 64)

		newStopInfo := stopInfo{KmbStopId: stop.Stop, KmbNameEn: stop.NameEn, KmbNameTc: stop.NameTc, KmbNameSc: stop.NameSc, Latitude: latitude, Longitude: longitude}
		stopInfos = append(stopInfos, newStopInfo)
	}

	return stopInfos
}

func kmbRouteStops() []routeStopInfo {
	var routeStopInfos []routeStopInfo

	resp, err := http.Get("https://data.etabus.gov.hk/v1/transport/kmb/route-stop")

	if err != nil {
		log.Fatalln(err)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	// Autogenerated via https://mholt.github.io/json-to-go/
	type JsonResponse struct {
		Type               string    `json:"type"`
		Version            string    `json:"version"`
		GeneratedTimestamp time.Time `json:"generated_timestamp"`
		Data               []struct {
			Route       string `json:"route"`
			Bound       string `json:"bound"`
			ServiceType string `json:"service_type"`
			Seq         string `json:"seq"`
			Stop        string `json:"stop"`
		} `json:"data"`
	}

	var jsonResponse JsonResponse
	err = json.Unmarshal(body, &jsonResponse)
	if err != nil {
		fmt.Println(err)
	}

	for _, routeStop := range jsonResponse.Data {
		if routeStop.Route == "94" {
			newRouteStopInfo := routeStopInfo{Route: routeStop.Route, Bound: routeStop.Bound, ServiceType: routeStop.ServiceType, Seq: routeStop.Seq, KmbStopId: routeStop.Stop}
			fmt.Println(newRouteStopInfo)
			routeStopInfos = append(routeStopInfos, newRouteStopInfo)
		}
	}
	return routeStopInfos
}

// func stopName(stopId string) string {
// 	resp, err := http.Get(fmt.Sprintf("https://data.etabus.gov.hk/v1/transport/kmb/stop/%s", stopId))

// 	if err != nil {
// 		log.Fatalln(err)
// 	}

// 	body, err := io.ReadAll(resp.Body)
// 	if err != nil {
// 		log.Fatalln(err)
// 	}

// 	// Autogenerated via https://mholt.github.io/json-to-go/
// 	type JsonResponse struct {
// 		Type               string    `json:"type"`
// 		Version            string    `json:"version"`
// 		GeneratedTimestamp time.Time `json:"generated_timestamp"`
// 		Data               struct {
// 			Stop   string `json:"stop"`
// 			NameEn string `json:"name_en"`
// 			NameTc string `json:"name_tc"`
// 			NameSc string `json:"name_sc"`
// 			Lat    string `json:"lat"`
// 			Long   string `json:"long"`
// 		} `json:"data"`
// 	}

// 	var jsonResponse JsonResponse
// 	err = json.Unmarshal(body, &jsonResponse)
// 	if err != nil {
// 		fmt.Println(err)
// 	}

// 	return jsonResponse.Data.NameEn
// }
